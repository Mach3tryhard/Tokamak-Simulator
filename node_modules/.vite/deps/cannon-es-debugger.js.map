{
  "version": 3,
  "sources": ["../../cannon-es-debugger/dist/cannon-es-debugger.js"],
  "sourcesContent": ["import { Vec3, Quaternion, Shape } from 'cannon-es';\nimport { MeshBasicMaterial, SphereGeometry, BoxGeometry, PlaneGeometry, Mesh, CylinderGeometry, BufferGeometry, Float32BufferAttribute } from 'three';\n\nfunction CannonDebugger(scene, world, _temp) {\n  let {\n    color = 0x00ff00,\n    scale = 1,\n    onInit,\n    onUpdate\n  } = _temp === void 0 ? {} : _temp;\n  const _meshes = [];\n\n  const _material = new MeshBasicMaterial({\n    color: color != null ? color : 0x00ff00,\n    wireframe: true\n  });\n\n  const _tempVec0 = new Vec3();\n\n  const _tempVec1 = new Vec3();\n\n  const _tempVec2 = new Vec3();\n\n  const _tempQuat0 = new Quaternion();\n\n  const _sphereGeometry = new SphereGeometry(1);\n\n  const _boxGeometry = new BoxGeometry(1, 1, 1);\n\n  const _planeGeometry = new PlaneGeometry(10, 10, 10, 10); // Move the planeGeometry forward a little bit to prevent z-fighting\n\n\n  _planeGeometry.translate(0, 0, 0.0001);\n\n  function createConvexPolyhedronGeometry(shape) {\n    const geometry = new BufferGeometry(); // Add vertices\n\n    const positions = [];\n\n    for (let i = 0; i < shape.vertices.length; i++) {\n      const vertex = shape.vertices[i];\n      positions.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3)); // Add faces\n\n    const indices = [];\n\n    for (let i = 0; i < shape.faces.length; i++) {\n      const face = shape.faces[i];\n      const a = face[0];\n\n      for (let j = 1; j < face.length - 1; j++) {\n        const b = face[j];\n        const c = face[j + 1];\n        indices.push(a, b, c);\n      }\n    }\n\n    geometry.setIndex(indices);\n    geometry.computeBoundingSphere();\n    geometry.computeVertexNormals();\n    return geometry;\n  }\n\n  function createTrimeshGeometry(shape) {\n    const geometry = new BufferGeometry();\n    const positions = [];\n    const v0 = _tempVec0;\n    const v1 = _tempVec1;\n    const v2 = _tempVec2;\n\n    for (let i = 0; i < shape.indices.length / 3; i++) {\n      shape.getTriangleVertices(i, v0, v1, v2);\n      positions.push(v0.x, v0.y, v0.z);\n      positions.push(v1.x, v1.y, v1.z);\n      positions.push(v2.x, v2.y, v2.z);\n    }\n\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    geometry.computeBoundingSphere();\n    geometry.computeVertexNormals();\n    return geometry;\n  }\n\n  function createHeightfieldGeometry(shape) {\n    const geometry = new BufferGeometry();\n    const s = shape.elementSize || 1; // assumes square heightfield, else i*x, j*y\n\n    const positions = shape.data.flatMap((row, i) => row.flatMap((z, j) => [i * s, j * s, z]));\n    const indices = [];\n\n    for (let xi = 0; xi < shape.data.length - 1; xi++) {\n      for (let yi = 0; yi < shape.data[xi].length - 1; yi++) {\n        const stride = shape.data[xi].length;\n        const index = xi * stride + yi;\n        indices.push(index + 1, index + stride, index + stride + 1);\n        indices.push(index + stride, index + 1, index);\n      }\n    }\n\n    geometry.setIndex(indices);\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    geometry.computeBoundingSphere();\n    geometry.computeVertexNormals();\n    return geometry;\n  }\n\n  function createMesh(shape) {\n    let mesh = new Mesh();\n    const {\n      SPHERE,\n      BOX,\n      PLANE,\n      CYLINDER,\n      CONVEXPOLYHEDRON,\n      TRIMESH,\n      HEIGHTFIELD\n    } = Shape.types;\n\n    switch (shape.type) {\n      case SPHERE:\n        {\n          mesh = new Mesh(_sphereGeometry, _material);\n          break;\n        }\n\n      case BOX:\n        {\n          mesh = new Mesh(_boxGeometry, _material);\n          break;\n        }\n\n      case PLANE:\n        {\n          mesh = new Mesh(_planeGeometry, _material);\n          break;\n        }\n\n      case CYLINDER:\n        {\n          const geometry = new CylinderGeometry(shape.radiusTop, shape.radiusBottom, shape.height, shape.numSegments);\n          mesh = new Mesh(geometry, _material);\n          shape.geometryId = geometry.id;\n          break;\n        }\n\n      case CONVEXPOLYHEDRON:\n        {\n          const geometry = createConvexPolyhedronGeometry(shape);\n          mesh = new Mesh(geometry, _material);\n          shape.geometryId = geometry.id;\n          break;\n        }\n\n      case TRIMESH:\n        {\n          const geometry = createTrimeshGeometry(shape);\n          mesh = new Mesh(geometry, _material);\n          shape.geometryId = geometry.id;\n          break;\n        }\n\n      case HEIGHTFIELD:\n        {\n          const geometry = createHeightfieldGeometry(shape);\n          mesh = new Mesh(geometry, _material);\n          shape.geometryId = geometry.id;\n          break;\n        }\n    }\n\n    scene.add(mesh);\n    return mesh;\n  }\n\n  function scaleMesh(mesh, shape) {\n    const {\n      SPHERE,\n      BOX,\n      PLANE,\n      CYLINDER,\n      CONVEXPOLYHEDRON,\n      TRIMESH,\n      HEIGHTFIELD\n    } = Shape.types;\n\n    switch (shape.type) {\n      case SPHERE:\n        {\n          const {\n            radius\n          } = shape;\n          mesh.scale.set(radius * scale, radius * scale, radius * scale);\n          break;\n        }\n\n      case BOX:\n        {\n          mesh.scale.copy(shape.halfExtents);\n          mesh.scale.multiplyScalar(2 * scale);\n          break;\n        }\n\n      case PLANE:\n        {\n          break;\n        }\n\n      case CYLINDER:\n        {\n          mesh.scale.set(1 * scale, 1 * scale, 1 * scale);\n          break;\n        }\n\n      case CONVEXPOLYHEDRON:\n        {\n          mesh.scale.set(1 * scale, 1 * scale, 1 * scale);\n          break;\n        }\n\n      case TRIMESH:\n        {\n          mesh.scale.copy(shape.scale).multiplyScalar(scale);\n          break;\n        }\n\n      case HEIGHTFIELD:\n        {\n          mesh.scale.set(1 * scale, 1 * scale, 1 * scale);\n          break;\n        }\n    }\n  }\n\n  function typeMatch(mesh, shape) {\n    if (!mesh) return false;\n    const {\n      geometry\n    } = mesh;\n    return geometry instanceof SphereGeometry && shape.type === Shape.types.SPHERE || geometry instanceof BoxGeometry && shape.type === Shape.types.BOX || geometry instanceof PlaneGeometry && shape.type === Shape.types.PLANE || geometry.id === shape.geometryId && shape.type === Shape.types.CYLINDER || geometry.id === shape.geometryId && shape.type === Shape.types.CONVEXPOLYHEDRON || geometry.id === shape.geometryId && shape.type === Shape.types.TRIMESH || geometry.id === shape.geometryId && shape.type === Shape.types.HEIGHTFIELD;\n  }\n\n  function updateMesh(index, shape) {\n    let mesh = _meshes[index];\n    let didCreateNewMesh = false;\n\n    if (!typeMatch(mesh, shape)) {\n      if (mesh) scene.remove(mesh);\n      _meshes[index] = mesh = createMesh(shape);\n      didCreateNewMesh = true;\n    }\n\n    scaleMesh(mesh, shape);\n    return didCreateNewMesh;\n  }\n\n  function update() {\n    const meshes = _meshes;\n    const shapeWorldPosition = _tempVec0;\n    const shapeWorldQuaternion = _tempQuat0;\n    let meshIndex = 0;\n\n    for (const body of world.bodies) {\n      for (let i = 0; i !== body.shapes.length; i++) {\n        const shape = body.shapes[i];\n        const didCreateNewMesh = updateMesh(meshIndex, shape);\n        const mesh = meshes[meshIndex];\n\n        if (mesh) {\n          // Get world position\n          body.quaternion.vmult(body.shapeOffsets[i], shapeWorldPosition);\n          body.position.vadd(shapeWorldPosition, shapeWorldPosition); // Get world quaternion\n\n          body.quaternion.mult(body.shapeOrientations[i], shapeWorldQuaternion); // Copy to meshes\n\n          mesh.position.copy(shapeWorldPosition);\n          mesh.quaternion.copy(shapeWorldQuaternion);\n          if (didCreateNewMesh && onInit instanceof Function) onInit(body, mesh, shape);\n          if (!didCreateNewMesh && onUpdate instanceof Function) onUpdate(body, mesh, shape);\n        }\n\n        meshIndex++;\n      }\n    }\n\n    for (let i = meshIndex; i < meshes.length; i++) {\n      const mesh = meshes[i];\n      if (mesh) scene.remove(mesh);\n    }\n\n    meshes.length = meshIndex;\n  }\n\n  return {\n    update\n  };\n}\n\nexport { CannonDebugger as default };\n"],
  "mappings": "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",
  "names": []
}
